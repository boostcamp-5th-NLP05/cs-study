# Chapter 02 : 데이터

> 컴퓨터는 오직 0과 1 밖에 모르는 바보

그럼 우리는 어떻게 정보들을 0과 1로 만 표현해서 컴퓨터가 이해할 수 있는 지 알고 있어야 한다.

## 정보 단위

컴퓨터가 이해할 수 있는 가장 작은 단위를 **비트(bit)** 라고 한다. 비트는 오직 0과 1 밖에 표현하지 못하는 단위이고, 이러한 비트들의 시퀀스로 정보들을 전달해주어야 한다.

하지만 비트가 너무 작은 단위이고 컴퓨터가 처리해야 할 정보는 매우x100 많기 때문에 사람은 비트 단위로 용량들을 보기엔 무리가 있다. 그렇기 때문에 바이트라는 단위가 등장하였고, 8개의 비트가 모여 1 바이트를 이룬다.

$$
1 byte = 8bit
$$

그리고 1,000개의 바이트가 모여 KB, 1,000개의 KB가 모여 MB, 1,000개의 MB가 모여 GB라 부른다.

토막 상식으로 10의 제곱 단위를 어떻게 표현하는 지도 알고 가자.

![image](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/2eaa3b23-7b1a-4917-92a2-fdf4fa634737)

출처 : https://bage.tistory.com/640

## 이진법

숫자를 0과 1로만 표현하는 방법을 이진법이라고 한다. 우리가 일상적으로 사용하는 숫자는 십진법을 따르고 있고, 0~9의 범위의 숫자로 모든 수를 표현한다. 9 이상의 수를 표현하기 위해서는 자릿수를 올려 10, 11과 같이 표현하는 것처럼 이진법에서도 0, 1로 표현할 수 있는 수의 범위를 넘어서면 자릿수를 올린다.

| 십진수 | 이진수 |
| --- | --- |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |

이제 5를 컴퓨터에게 알려주기 위해서는 101을 알려주면 된다는 것을 알 수 있다.

하지만 101이 이진수 101인지, 십진수 101인지 알 수 없기 때문에 보통 이진수 앞에는 0b를 붙여 0b101과 같이 표현한다. 표기법으로는 아래 첨자를 많이들 쓰지만, 프로그래밍 단계에서는 앞에 0b를 붙인다고 생각하면 된다.

### 그럼 음수는 어떻게 표현하지!?

가장 많이 사용되는 방법은 2의 보수를 구하여 이를 음수로 간주하는 방법이다.

<aside>
💡 2의 보수란?
어떤 수를 그보다 큰 2^n에서 뺀 값이다.
예를 들어 0b11의 2의 보수는 0b11보다 큰 2^n인 0b100에서 0b11을 뺀 0b01이 된다.

</aside>

하지만 이를 매번 계산할 수는 없으니, 간단하게 계산하는 방법이 있다. 모든 비트를 반대로 뒤집고 1을 더하면 된다.

0b11의 예시로 들면, 0b11의 비트를 모두 뒤집으면 0b00이 되고, 여기에 1을 더하면 0b01이 된다. ~~참 쉽죠?~~ 

하지만 여기서 문제가 또 하나 발생하는데, 0b01이라고만 적으면 이게 음수인지 양수인지 보는 컴퓨터 입장에서는 구분이 되지 않는다. 그렇기 때문에 **플래그** 를 사용하는데, **플래그** 는 이 수가 양수인지 음수인지 알려주는 역할을 한다.

## 십육진법

십육진법은 16개의 숫자로 수를 표현하는 방법이다. 십육진법을 사용하면 좋은 점은 데이터를 더욱 짧게 표현할 수 있다는 것이고, 1 바이트(8 비트)를 표현할 때 십육진법에서는 2개의 숫자(혹은 알파벳)으로 데이터를 표현할 수 있다는 장점이 있다. 십육진법을 표현할 땐 0x 를 prefix로 둔다.(ex. 0x1A, 0x123) 

> 위에서는 숫자를 0과 1로 표현하는 방법에 대해서 알아보았으니, 이제 문자 표현법을 알아볼 차례이다.


## 문자 집합과 인코딩

- 문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 : 문자를 0과 1로 변환하는 과정
- 문자 디코딩 : 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정

위와 같은 과정을 통해 컴퓨터와 사람은 문자로 소통할 수 있다.

## 아스키 코드

![image](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/5a3f72ff-af7d-4b05-b48c-7320101056ff)

출처: [https://velog.io/@exploit017/아스키-코드표](https://velog.io/@exploit017/%EC%95%84%EC%8A%A4%ED%82%A4-%EC%BD%94%EB%93%9C%ED%91%9C)

아스키 코드는 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함한다. 아스키 코드는 각각 7개의 비트로 표현되는데, 이 때문에 128개의 문자만 표현할 수 있다는 한계점이 있다.

이러한 한계점을 해결하기 위해 다양한 인코딩 방식들이 등장했다.

## EUC-KR

한글은 다른 언어와 다르게 초성, 중성, 종성이라는 특이한 형태를 가진 언어이다.

그렇기 때문에 완성된 하나의 글자에 코드를 부여하는 **완성형 인코딩** 과 초성, 중성, 종성 각각에 비트열을 할당하는 **조합형 인코딩** 방식이 있다.

**EUC-KR**의 경우 완성형 인코딩을 사용하고 있으며, 총 2,350개의 한글 단어를 표현할 수 있다. 하지만 ‘쀍’, ‘쀓’, ‘믜’와 같이 단어 조합에 등장하지 않는 단어는 인코딩할 수 없다는 한계점이 있었다.

## 유니코드와 UTF-8

**EUC-KR**의 경우 한글에 특화된 인코딩인데, 만약 여러 언어들이 각자의 인코딩을 가지고 있다면 사용하고자 하는 모든 언어에 대한 인코딩 방식을 이해해야한다. 그렇기 때문에 모든 언어를 아우르는 문자 집합과 통일된 표준 인코딩 방식에 대한 필요성이 제기되었고, 이러한 이유로 등장한 것이 **유니코드**이다. 

유니코드는 글자에 부여된 값을 그대로 인코딩 값으로 삼지 않고, UTF-8, UTF-16, UTF-32 등의 방식으로 유니코드 문자에 부여된 값을 인코딩한다. 

<img width="1178" alt="image" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/6f5746e1-49f5-4661-8f79-58d0efee6c10">

출처 : https://www.unicode.org/roadmaps/smp/

위 표는 유니코드 문자에 포함된 문자들의 목록 중 일부인데, 거의 모든 언어를 담고 있다고 무방하고 지금도 계속 추가되는 중이라고 한다. 전체 표에서 60% 가량이 공백이기 때문에 새로운 언어가 등장해도 그 단어들을 모두 표현할 수 있을 것으로 예상한다.

UTF-8 방식은 아래 표를 따른다.

<img width="812" alt="image" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/0396468a-5b24-41e9-9464-c6ff9477d3bb">

출처 : https://namu.wiki/w/UTF-8

변환 예시는 다음과 같다.
- 1개 바이트를 사용:
  - 가장 큰 비트에 0을 할당하고, 나머지 7비트에 기존의 아스키 코드를 모두 할당한다. 0xxxxxxx 값을 모두 사용하였다. (아직 1xxxxxxx는 사용 가능한 상황이다.)
- 사용하려는 바이트가 2개가 넘을 때: 첫 바이트에는 몇바이트를 사용하는지 알려주는 비트를 먼저 넣는다.
  - 2바이트(110), 3바이트(1110), 4바이트(11110)
  - 나머지 바이트에는 여러 바이트에서 연결되었음을 알리는 비트를 먼저 넣는다. 이 때 2바이트 표식을 넣은 데이터와 겹치지 않도록, 10 이라는 비트를 넣어준다.
- 표식 비트가 아닌 나머지 비트들은 모두 데이터 비트로 사용한다.

![image](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/60be1118-6ec6-4331-a5e7-039c985bcc67)

출처 : https://namu.wiki/w/UTF-8
