# 03-1 소스 코드와 명령어

## 고급 언어와 저급 언어
### 고급 언어
  사람을 위한 언어 - 프로그래밍 언어
### 저급 언어
  컴퓨터가 직접 이해하고 실행할 수 있는 언어 - 명령어로 이루어져 있음
  명령어로 반환되어야 고급 언어로 작성된 소스코드가 실행될 수 있음
  - 어셈블리어
  - 기계어
### 기계어
  - 0과 1로 이루어진 명령어 모음
### 어셈블리어
  - 사람이 기계어를 읽으면 의미를 이해하기 어려워서 등장
  - 0과 1로 표현된 **명령어(기계어)를 읽기 편한 형태로 번역한 언어**
  - 하드웨어와 밀접한 연관이 있는 임베디드 개발자, 게임개발자 등 어셈블리어를 많이 이용하는 개발자도 있다.
  
++ 복잡한 프로그램을 구현하기 위해서 고급언어가 필요함

## 컴파일 언어와 인터프리터 언어 - 고급언어가 저급언어로 변환되어 작동하는 프로그래밍 언어
### 컴파일 언어 ex) C
  - 컴파일(코드 **전체**가 저급 언어로 변환되는 과정) 방식으로 작동하는 프로그래밍 언어
  - 컴파일러(컴파일을 수행해 주는 도구)에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
  - 목적 코드 : 컴파일러를 통해 저급 언어로 변환된 코드
### 인터프리터 언어 ex) python
  - 인터프리트 방식으로 작동하는 프로그래밍 언어
  - 인터프리터(소스코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구)에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
  - 컴파일 언어보다 느림

++ 컴파일 언어와 인터프리터 언어는 명확히 구분되지 않고 경계가 모호한 경우가 많다.

<좀 더 알아보기>
## 목적 파일 VS 실행 파일
### 목적 파일 - 목적 코드(컴퓨터가 이해하는 저급 언어)로 이루어진 파일
### 실행 파일 - 실행 코드로 이루어진 파일
### 링킹
  - 목적 코드가 실행 파일이 되기 위해서 거치는 작업


# 03-2 명령어의 구조

## 연산 코드와 오퍼랜드
명령어 = 연산코드(연산자) X 오퍼랜드(피연산자)
### 연산코드
  - 명령어가 수행할 연산
  - 연산코드 필드 : 연산코드가 담기는 영역
  - 유형
    - 데이터 전송 : MOVE, STORE, LOAD(FETCH), PUSH, POP 등
    - 산술,논리연산 : ADD/SUBTRACT/MULTIPLY/DIVED, INCREMENT/DECREMENT, AND/OR/NOT, COMPARE 등
    - 제어 흐름 변경 : JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN 등
    - 입출력 제어 : READ(INPUT), WRITE(OUTPUT), START IO, TEST IO 등
### 오퍼랜드
  - 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치(메모리 주소나 레지스터 이름)
  - 오퍼랜드 필드(주소 필드) : 오퍼랜드가 담기는 영역
  - 오퍼랜드의 개수에 따라 명령어를 N-주소 명령어라고 함

![연산코드와 오퍼랜드]([https://velog.velcdn.com/images/thdgusrbek/post/839eb4c2-6a85-4ada-ba21-212abe3713.png])


## 주소 지정 방식 - 연산에 사용할 데이터 위치를 찾는 방법
명령어 길이를 위해 지정
유효주소 : 연산의 대상이 되는 데이터가 저장된 위치
### 즉시 주소 지정 방식
 - 연산에 사용할 **데이터**를 오퍼랜드 필드에 직접 명시, 빠름
### 직접 주소 지정 방식
  - 오퍼랜드 필드에 **유효 주소**를 직접적으로 명시, 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듬
### 간접 주소 지정 방식
  - **유효 주소의 주소**를 오퍼랜드 필드에 명시, 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐, 느림

### 레지스터 주소 지정 방식
  - 연산에 사용할 데이터를 저장한 **레지스터**를 오퍼랜드 필드에 직접 명시
  - CPU 외부에 있는 메모리에 접근하는 것보다 내부에 있는 레지스터에 접근하는 것이 더 빠름
  - 레지스터 크기에 제한이 생길 수 있음
### 레지스터 간접 주소 지정 방식
  - 연산에 사용할 데이터를 메모리에 저장, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
  - 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점
  
  
  
<좀 더 알아보기>
## 스택과 큐
### 스택
  - 한쪽 끝이 막혀 있는 통과 같은 저장공간
  - 후입선출 (LIFO)
  - 새로운 데이터 저장하는 명령어 PUSH, 스택에 저장된 데이터를 꺼내는 명령어 POP
### 큐
  - 양쪽이 뚫려 있는 통과 같은 저장공간
  - 선입선출 (FIFO)
