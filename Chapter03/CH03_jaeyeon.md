# Chapter 03: 명령어

앞서 데이터 챕터에서 컴퓨터가 사람의 말을 어떻게 이해하는지, 

인간의 언어가 데이터로 변환 되는 과정을 볼 수 있었다.

그렇다면 내가 짠 소스 코드는 인간의 언어이고 텍스트인데, 

이것이 그저 데이터로만 변환된다면 CPU가 연산을 할 순 없을 것이다.

소스코드가 어떤 과정을 통해 명령어로 바뀌는지 알아보자.

## 고급 언어와 저급 언어

먼저 CS 분야에서의 언어에 대해서 이해해야 한다. 크게 고급 언어와 저급 언어로 나뉠 수 있고, 고급 언어는 사람이 이해하기 쉽고 저급 언어는 컴퓨터가 이해하기 쉬운 언어이다. 

고급 언어는 대부분의 프로그래밍 언어(C, C++, JAVA, Python 등)이 속하고 저급 언어는 기계어와 어셈블리어가 있다.

그렇기 때문에 고급 언어를 저급 언어로 변환해주는 과정이 필요하다.

하지만 염두에 둬야하는건, 컴퓨터는 여전히 어셈블리어는 모른다. 어셈블리어는 기계어를 사람이 읽기 쉽도록 단어로 표현한 것이지 컴퓨터가 이 단어를 아는 것은 아니다.

C언어를 어셈블리어로 바꾼 예시를 보자.

```c
int main(int argc, char* argv[]){
    int sum = 0;
    for (int i=0; i < 10; i++){
        sum += i;
    }
    return 0;
}
```

```nasm
main:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     QWORD PTR [rbp-32], rsi
        mov     DWORD PTR [rbp-4], 0
        mov     DWORD PTR [rbp-8], 0
        jmp     .L2
.L3:
        mov     eax, DWORD PTR [rbp-8]
        add     DWORD PTR [rbp-4], eax
        add     DWORD PTR [rbp-8], 1
.L2:
        cmp     DWORD PTR [rbp-8], 9
        jle     .L3
        mov     eax, 0
        pop     rbp
        ret
```

단순한 반복문도 다음과 같이 긴 명령어로 변환된다. 

## 고급 언어의 종류

고급 언어는 크게 컴파일 언어와 인터프리터 언어로 구분 된다. 

대표적인 컴파일 언어는 C, 인터프리터 언어는 Python이 있다.

### 컴파일 언어

컴파일 언어의 경우 소스 코드 전체를 먼저 컴파일하여 저급 언어인 목적 코드를 만들어낸다.

C의 대표적인 컴파일러로는 gcc가 있는데, 아래와 같은 코드를 통해 목적 코드를 생성할 수 있다.

```bash
gcc -c main.c
```

필요한 소스 코드들을 모두 목적 파일로 변환한 뒤 링킹 단계를 거치면 실행할 수 있는 프로그램이 완성된다.

### 인터프리터 언어

인터프리터 언어는 위에서부터 한 줄씩 차례대로 저급 언어로 해석하여 실행한다고 보면 된다.

컴파일 단계를 거치지 않고 바로 실행된다는 장점이 있지만,

소스 코드의 1200번줄에 에러가 있어도 1199번줄까지는 실행이 되어 디버깅이 용이하지 않다는 단점이 있다.

## 연산 코드와 오퍼랜드

컴퓨터의 명령어는 크게 아래와 같은 구조로 이루어져 있다.

<img width="672" alt="Group 1" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/4ae460f4-1ec6-46fb-b28f-4a2a65c78ff4">

- 연산 코드 : 명령어가 수행할 연산
- 오퍼랜드 : 연산에 사용할 데이터 혹은 연산에 사용할 데이터가 저장된 위치

위에서 C를 어셈블리로 변환한 결과를 보면, push, mov, jmp 등이 연산 코드에 해당하며 rbp, rsp 레지스터와 .L2와 같은 부분은 오퍼랜드에 해당된다. 연산 코드에 따라서 필요한 오퍼랜드의 개수는 0개부터 3개까지 다양하다.

### 연산 코드

연산 코드는 크게 네 유형으로 분류된다.

1. 데이터 전송 : MOVE, STORE, PUSH, POP 등
2. 산술/논리 연산 : ADD, INCREMENT, AND, CMP 등
3. 제어 흐름 변경 : JUMP, CALL, RETURN 등
4. 입출력 제어 : READ, WRITE 등

## 주소 지정 방식

오퍼랜드에는 연산에 사용할 데이터가 저장된 위치를 넣을 수도 있다고 했는데, 과연 주소는 어떻게 지정되는 건지 알아보자.

“오퍼랜드에 데이터의 위치가 아니라 데이터를 넣으면 더 빠르지 않나?”

맞는 말이다.

맞는 말이지만 오퍼랜드 필드의 크기는 한정되어 있고 그 범위가 크지 않다. 그렇기 때문에 메모리에 데이터를 넣어두고 메모리의 위치를 오퍼랜드로 알려준다면 더 많은 데이터를 처리할 수 있다. 

레지스터도 마찬가지로 레지스터의 이름을 오퍼랜드로 사용하는 것이 데이터를 많이 다룰 수 있다.

### 즉시 주소 지정 방식

이 방식은 연산에 사용할 데이터를 바로 오퍼랜드에 바로 넣어두는 방식이다.

### 직접 주소 지정 방식

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다. 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 커졌지만, 유효 주소를 표현할 수 있느 범위는 연산 코드의 비트 수만큼 줄어들었다.

### 간접 주소 지정 방식

유효 주소의 주소를 오퍼랜드에 넣는 방식이다. 메모리 안에 유효 주소를 담고 있는 부분이 있고, 이 부분의 주소를 오퍼랜드에 담는 것이다. 이런 식으로 하면 표현할 수 있는 유효 주소의 범위는 늘릴 수 있지만 두 번의 메모리 접근 때문에 일반적으로 느리다는 단점이 있다.

하지만 데이터의 표현 범위가 비약적으로 늘어났다는 점에서, 이러한 기법을 잘 이해하고 기억하고 있어야 한다. 뒤에 CPU 배울 때 비슷한 기법을 또 사용할 것이다.

### 레지스터 주소 지정 방식

이 방법은 레지스터의 이름을 오퍼랜드에 직접 명시하는 것이다. 

### 레지스터 간접 주소 지정 방식

이 방법은 레지스터 내에 유효 주소를 저장하고 오퍼랜드에는 레지스터의 이름을 기록하는 방법이다.

메모리에 접근 하는 횟수가 한 번으로 줄어들기 때문에 메모리에 두 번 접근하는 간접 주소 지정 방식보다 빠르다.
