# Chapter 11 CPU 스케줄링

## 11-1 CPU 스케줄링 개요

- 프로세스 우선순위
  |입출력 집중 프로세스|CPU 집중 프로세스|
  |---|---|
  |eg) 비디오 재생, 디스크 백업 작업 담당 프로세스|eg) 복잡한 수학 연산, 컴파일, 그래픽 처리 작업 담당 프로세스|
  |실행 상태 < 대기 생태|실행 상태 > 대기 상태|
  |입출력 버스트(I/O burst)가 많다|CPU 버스트(CPU burst)가 많다|
  - *입출력 작업이 많은 프로세스를 먼저 실행하는 것이 효율적이다*. 
  - 입출력 집중 프로세스를 먼저 처리해서 대기 상태로 만들어 버리고 다른 프로세스가 CPU를 사용할 수 있도록 한다.
  - **우선순위(priority)** 를 PCB에 명시
- **스케줄링 큐**
  - CPU가 PCB를 탐색해서 다음으로 실행할 프로세스를 찾는 것이 아닌 *프로세스가 줄을 서서 기다리게 하는 것*
  - **준비 큐(ready queue)**: CPU를 이용하기 위해 기다리는 줄
  - **대기 큐**: 입출력장치를 이용하기 위해 기다리는 줄
  - 높은 우선순위 먼저 실행
- 선점형과 비선점형 스케줄링
    |선점형(preemptive) 스케줄링|비선점형(non-preemptive) 스케줄링|
    |---|---|
    |운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에게 할당|프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 자원 사용을 독점|
    |문맥 교환 과정에서 오버헤드 발생|문맥 교환 과정 적음|
  

## 11-2 CPU 스케줄링 알고리즘

1. **선입 선처리 스케줄링, First Come First Served Scheduling**
    - 준비 큐에 삽입된 순서대로 처리하는 비선점형 스케줄링
    - **호위 효과(convoy effect)**: CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 긴 시간을 기다려야 함.
2. **최단 작업 우선 스케줄링, Shortest Job First Scheduling**
   - CPU 이용 시간의 길이가 가장 짧은 프로세스부터 처리
3. **라운드 로빈 스케줄링, round robin scheduling**
    - 정해진 타임 슬라이스만큼 돌아가며 CPU를 이용하는 선점형 스케줄링
    - **타임 슬라이스**: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
    - 타임 슬라이스가 지나치게 크면 선입 선처리 스케줄링처럼 호위 효과 발생
    - 타임 슬라이스가 지나치게 작으면 문맥 교환을 하느라 프로세스 처리를 못 함
5. **최소 잔여 시간 우선 스케줄링, Shortest Remaining Time Scheduling**
   - 최단 작업 우선 스케줄링 + 라운드 로빈 알고리즘
   - 정해진 타임 슬라이스만큼 CPU를 사옹하고, 남아있는 작업 시간이 가장 적은 프로세스부터 처리
6. **우선순위 스케줄링, priority scheduling**
   - 높은 우선순위를 가진 프로세스부터 처리
   - **기아(starvation) 현상**: 우선순위가 낮은 프로세스는 계속 뒤로 밀리는 현상
   - **에이징**: 기아 현상을 방지하기 위해 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
7. **다단계 큐 스케줄링, multilevel queue scheduling**
   - 우선순위별로 준비 큐를 여러 개 사용해서 우선순위가 가장 높은 큐에 있는 프로세스 먼저 처리
   - 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리
   - 큐별로 타임 슬라이스와 스케줄링 알고리즘을 다르게 사용 가능
8. **다단계 피드백 큐 스케줄링, multilevel feedback queue scheduling** &larr; 가장 일반적인 방법
   - 프로세스들이 큐 사이 이동 가능
   - 프로세스가 해당 큐에서 실행이 끝나지 않으면 밑 우선순위 큐에 삽입.
   - CPU를 오래 사용해야 하는 프로세스는 점차 우선순위 낮아짐. 입출력 집중 프로세스들은 자연스럽게 우선순위 높아짐. 
   - 에이징 기법 적용 가능
