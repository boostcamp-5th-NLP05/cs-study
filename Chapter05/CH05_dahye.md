# CPU 성능 향상 기법

# 05-1 빠른 CPU를 위한 설계 기법

## 클럭
  - 클럭 속도가 높을수록 CPU가 빠르게 동작함
  - 오버클럭킹(overclocking) : 최대 클럭 속도를 강제로 더 끌어올리는 것 (클럭 속도는 일정하지 않음)
  
++ 클럭 속도외에 CPU의 성능을 높이는 방법들 - 코어와 스레드 수 늘리기
## 코어와 멀티코어
### 코어(core)
  -  (현재기준) 명령어를 실행하는 부품이며, CPU 내부에 여러 개가 존재 (전통적인 관점에서는 하나만 존재)
### 멀티코어 CPU (멀티코어 프로세서)
  - 코어를 여러 개 포함하고 있는 CPU
일반적으로 코어가 많을수록 연산 속도가 빨라지나, 반드시 코어의 수에 비례하여 연산 속도가 빨라지는 것은 아니며, 코어마다 처리할 연산이 적절하게 분배되어야 함
**코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐가 중요**

## 스레드와 멀티 스레드
### 스레드(thread)
  -  사전적 의미 : 실행 흐름의 단위
  -  CPU에 사용되는 스레드와 프로그래밍에서 사용되는 스레드는 용례가 다름
  -  CPU에서 사용되는 하드웨어적 스레드, 프로그램에서 사용하는 소프트웨어적 스레드가 있음
### 하드웨어적 스레드
  - 하나의 코어가 동시에 처리하는 명령어 단위
  - 1코어 N스레드 -> 1개의 코어가 1회당 N개의 명령어를 실행
  - 멀티스레드 프로세서/CPU : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
  - 하이퍼스레딩(hyper-threading) : 인텔의 멀티스레드 기술을 의미
### 소프트웨어적 스레드
  - 하나의 프로그램에서 독립적으로 실행되는 단위
  - 하나의 프로그램은 한 부분만 실행될 수도, 여러 부분이 동시에 실행될 수도 있음
### 멀티스레드 프로세서
  - 멀티스레드 프로세서의 설계의 핵심은 레지스터임
  - 하나의 코어로 여러 명령어를 동시에 처리하기 위해서는 명령어를 처리하기 위해 필요한 레지스터(프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터 등)를 여러 개 가지고 있어야 함 -> 레지스터 세트
  - 논리 프로세서(logical processor) 라고도 불림
  - 2코어 4스레드 CPU -> 한 번에 네 개의 명령어를 처리가능 -> 메모리 속 프로그램은 한 번에 하나의 명령어를 처리하는 CPU가 4개 있는 것으로 보임


# 05-2 명령어 병렬 처리 기법
CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것이 중요
명령어 처리 기법으로는 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있음
## 명령어 파이프라인
### 명령어 처리 과정을 클럭 단위로 나눌 경우 (일반적)
**같은 단계가 겹치지만 않으면 CPU는 '각 단계를 동시에 실행'할 수 있음**
  - 명령어 인출(Instruction Fetch)
  - 명령어 해석(Instruction Decode)
  - 명렁어 실행(Execute Instruction)
  - 결과 저장(Write Back)
### 명렁어 파이프라이닝(instruction pipelining)
  - 명령어들을 명령어 파이프라인(instruction pipeline)에 넣고 동시에 처리하는 기법
### 파이프라인 위험(pipeline hazard) - 특정 상황에서 성능 향상에 실패하는 경우
  - 데이터 위험 : '데이터 의존성' - 모든 명령어를 동시에 처리할 수는 없음
  - 제어 위험 : 분기 등의 프로그램 카운터의 갑작스러운 변화에 의해 발생
    ++ 분기 예측(프로그램이 어디로 분기할 지 미리 예측하고 그 주소를 인출)을 통해 방지 
  - 구조적 위험(자원 위험) : 명령어들을 겹쳐서 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등의 CPU 부품을 사용하려 할 때 발생

## 슈퍼스칼라
CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
### 슈퍼스칼라 프로세서/CPU
  - 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
  - 멀티스레드 프로세서 -> 슈퍼스칼라 구조를 사용 가능(한 번에 여러 명령어를 인출, 해석, 실행할 수 있기 때문)
  - 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지나, 파이프라인 위험 등의 예상치 못한 문제가 있을 수 있으므로 고도로 설계되어야 함

## 비순차적 명령어 처리(OoOE)
명령어들을 순차적으로 실행하지 않는 명령어 병렬 처리 기법 **합법적인 새치기**
순서를 바꿔 실행해도 무방한(의존 관계가 없는) 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지


# 05-3 CISC와 RISC
CPU가 파이프라이닝, 슈퍼스칼라 기법을 효과적으로 사용하려면 -> 명령어가 파이프라이닝하기 쉽게 생겨야 함
## 명령어 집합(명령어 집합 구조) = ISA(Instruction Set Architecture)
- CPU가 이해할 수 있는 명령어들의 모음
- CPU마다 ISA가 다를 수 있음
- ISA가 다르다 -> CPU가 이해할 수 있는 명령어가 다르다 -> 어셈블리어가 달라진다
- ISA는 **CPU의 언어**이자 **하드웨어가 소프트웨어를 어떻게 이해할지**에 대한 약속
- 명령어의 생김새 뿐만아니라 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수 등이 달라짐

++ 명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리를 사용하기에 유리한 ISA가 있고 그렇지 못한 ISA도 있음
## CISC(Complex Instruction Set Computer)
- 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식
- x86, x86-64 등이 있음
- 가변 길이 명령어 : 다양하고 강력한 기능의 명령어 집합을 활용, 명령어의 형태와 크기, 지정 방식이 다양
- 장점 : 적은 수의 명령어로도 프로그램을 실행할 수 있음 -> 컴파일된 프로그램의 크기가 작고 메모리 절약 
- 단점: 활용하는 명령어가 복잡하고 다양한 기능을 제공 -> 명령어의 크기와 실행되기까지의 시간 일정하지 않음, 여러 클럭 주기 필요로 함 -> 명령어 파이프라인 구현에 걸림돌

## RISC (Reduced Instruction Set Computer)
- CISC의 단점을 보완
- ARM 등이 있음
- 고정 길이 명령어 : 명령어의 길이와 수행 시간이 짧고 규격화됨 (자주 쓰이는 기본적인 명령어를 작고 빠르게 만들었음)
- 장점 : 짧고 규격화된 명령어를 활용, 메모리 접근 단순화 및 최소화 -> 주소 지정 방식의 종류 적음
- 단점 : CISC보다 레지스터를 이용하는 연산이 많음, 범용 레지스터 개수도 많음 (레지스터를 적극사용)

## CISC VS RISC
- 복잡하고 다양한 명령어 VS 단순하고 적은 명령어
- 가변 길이 명령어 VS 고정 길이 명령어
- 다양한 주소 지정 방식 VS 적은 주소 지정 방식
- 프로그램을 이루는 명령어의 수가 적음 VS 프로그램을 이루는 명령어의 수가 많음
- 여러 클럭에 걸쳐 명령어 수행 VS 1클럭 내외로 명령어 수행
- 파이프라이닝 하기 어려움 VS 파이프라이닝 하기 쉬움

