# Chapter 04 CPU의 작동 원리 (미완성)

## 04-1 ALU와 제어장치

### ALU - 계산

TODO [사진]

제어 신호는 어떤 연산을 수행해야 하는지 알려준다.

> **Q. ALU의 결과값이 메모리가 아닌 레지스터에 저장되는 이유?**
>
> CPU가 메모리에 접근하는 속도는 레지스터보다 훨씬 느리기 때문이다. ALU에서 결과가 나올 때마다 메모리에 접근하면 프로그램 실행 속도를 늦출 수 있다.

#### 플래그

플래그는 연산 결과에 대한 추가적인 정보를 담고 있다. \
플래그 레지스터에 저장된다.

|플래그 종류|의미|
|---|---|
|부호 플래그|연산한 결과의 부호를 나타냄|
|제로 플래그|연산 결과가 0인지 나타냄|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지 나타냄|
|오버플로우 플래그|**오버플로우**가 발생했는지 나타냄|
|인터럽트 플래그|인터럽트[^1]가 가능한지 나타냄|
|슈퍼바이저 플래그|커널 모드인지 사용자 모드[^2]를 나타냄|

> 오버플로우(overflow): 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

[^1]: 인터럽트는 04-3절에서 설명
[^2]: 커널 모드와 사용자 모드는 9장에서 설명

### 제어장치 - 제어 신호 생성 및 명령어 해석

TODO [사진]

#### 받아들이는 정보

1. **클럭 신호**
   - 클럭(clock): 컴퓨터의 모든 부품이 맞춰 작동하는 시간 단위.
2. 해석해야 할 **명령어** from 명령어 레지스터
3. **플래그** from 플래그 레지스터
4. CPU 외부로부터 전달된 **제어 신호** from 제어 버스

#### 내보내는 정보

- CPU 내부에 전달하는 제어 신호
  - 레지스터, ALU
- CPU 외부에 전달하는 제어 신호
  - 메모리, 입출력장치, 보조기억장치

## 04-2 레지스터

### 레지스터 종류

|레지스터 종류|설명|
|---|---|
|**프로그램 카운터**(PC: Program Counter, IP: Instruction Pointer)|메모리에서 가져올 명령어의 주소 저장|
|**명령어 레지스터**(IR: Instruction Register)|메모리에서 읽어 들인 명령어 저장. 값을 제어 장치에게 전달|
|**메모리 주소 레지스터**(MAR: Memory Address Register)|CPU가 읽어 들이고자 하는 주소값 저장. 값을 주소 버스에 전달|
|**메모리 버퍼 레지스터**(MBR: Memory Buffer Register)|메모리와 주고받을 값(데이터, 명령어) 저장. 값을 데이터 버스와 주고받음|
|**플래그 레지스터**|ALU 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장|
|**범용 레지스터**|다양한 상황에서 자유롭게 사용|
|**스택 포인터**|스택에 마지막으로 저장한 값의 위치 저장|
|**베이스 레지스터**|베이스 레지스터 주소 지정 방식에서 기준 주소 저장|

> CPU 제조사마다 레지스터 이름과 역할이 조금씩 다르다.

#### 명령어 읽어 드리는 과정

TODO

- 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터 사용
- 순차적인 실행 흐름이 끊기는 경우

#### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식.

> **스택 영역**
>
> 메모리 안에 스택처럼 사용하기로 정해져 있는 영역.

#### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식(displacement addressing mode)

명령어는 다음 형식을 지닌다.

|연산 코드|레지스터|오퍼랜드|
|---|---|---|

- 상대 주소 지정 방식
  - 유효 주소: 오퍼랜드와 프로그램 카운터의 값을 더한 값
  - if문 처럼 특정 주소의 코드를 실행할 때 사용
- 베이스 레지스터 주소 지정 방식
  - 유효 주소: 오퍼랜드와 베이스 레지스터의 값을 더한 값.

## 04-3 명령어 사이클과 인터럽트

TODO


