# Chapter 04 CPU의 작동 원리 (미완성)

## 04-1 ALU와 제어장치

### ALU - 계산

<img width="500" alt="ALU" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/81620001/205b1516-d83e-427b-b524-17fe4d2ade95">\
_사진 출처: 혼자 공부하는 컴퓨터 구조 + 운영체제, 강민철, 한빛미디어_

> **Q. ALU의 결과값이 메모리가 아닌 레지스터에 저장되는 이유?**
>
> CPU가 메모리에 접근하는 속도는 레지스터보다 훨씬 느리기 때문이다. ALU에서 결과가 나올 때마다 메모리에 접근하면 프로그램 실행 속도를 늦출 수 있다.

#### 플래그

플래그는 연산 결과에 대한 추가적인 정보를 담고 있다. \
플래그 레지스터에 저장된다.

|플래그 종류|의미|
|---|---|
|**부호 플래그**|연산한 결과의 부호를 나타냄|
|**제로 플래그**|연산 결과가 0인지 나타냄|
|**캐리 플래그**|연산 결과 올림수나 빌림수가 발생했는지 나타냄|
|**오버플로우 플래그**|**오버플로우**가 발생했는지 나타냄|
|**인터럽트 플래그**|인터럽트[^1]가 가능한지 나타냄|
|**슈퍼바이저 플래그**|커널 모드인지 사용자 모드[^2]를 나타냄|

> 오버플로우(overflow): 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

[^1]: 인터럽트는 04-3절에서 설명
[^2]: 커널 모드와 사용자 모드는 9장에서 설명

### 제어장치 - 제어 신호 생성 및 명령어 해석

<img width="500" alt="제어장치" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/81620001/1f3fa0b4-6364-4409-aa84-25ced1f5c57f">\
_사진 출처: 혼자 공부하는 컴퓨터 구조 + 운영체제, 강민철, 한빛미디어_

#### 받아들이는 정보

1. **클럭 신호**
   - 클럭(clock): 컴퓨터의 모든 부품이 맞춰 작동하는 시간 단위.
2. 해석해야 할 **명령어** from 명령어 레지스터
3. **플래그** from 플래그 레지스터
4. CPU 외부로부터 전달된 **제어 신호** from 제어 버스

#### 내보내는 정보

- CPU 내부에 전달하는 제어 신호
  - 레지스터, ALU
- CPU 외부에 전달하는 제어 신호
  - 메모리, 입출력장치, 보조기억장치

---

## 04-2 레지스터

### 레지스터 종류

|레지스터 종류|설명|
|---|---|
|**프로그램 카운터**(PC: Program Counter, IP: Instruction Pointer)|메모리에서 가져올 명령어의 주소 저장|
|**명령어 레지스터**(IR: Instruction Register)|메모리에서 읽어 들인 명령어 저장. 값을 제어 장치에게 전달|
|**메모리 주소 레지스터**(MAR: Memory Address Register)|CPU가 읽어 들이고자 하는 주소값 저장. 값을 주소 버스에 전달|
|**메모리 버퍼 레지스터**(MBR: Memory Buffer Register)|메모리와 주고받을 값(데이터, 명령어) 저장. 값을 데이터 버스와 주고받음|
|**플래그 레지스터**|ALU 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장|
|**범용 레지스터**|다양한 상황에서 자유롭게 사용|
|**스택 포인터**|스택에 마지막으로 저장한 값의 위치 저장|
|**베이스 레지스터**|베이스 레지스터 주소 지정 방식에서 기준 주소 저장|

> CPU 제조사마다 레지스터 이름과 역할이 조금씩 다르다.

#### 명령어 읽어 드리는 과정

1. **프로그램 카운터**에 실행할 명령어의 주소가 저장
2. **메모리 주소 레지스터**에 명령어 주소 이동
3. *메모리 읽기* 제어 신호는 제어 버스를 통해, 메모리 주소 레지스터 값은 주소 버스를 통해 메모리로 전달
4. 읽어온 값은 데이터 버스를 통해 **메모리 버퍼 레지스터**에 저장. **프로그램 카운터** 증가.
5. 메모리 버퍼 레지스터에 저장된 값은 **명령어 레지스터**로 이동
6. 제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생

1~5는 인출 사이클, 6은 실행 사이클에 포함된다. 위 사이클을 반복하면서 CPU는 프로그램을 차례대로 실행한다.

> JUMP, CONDITIONAL JUMB CALL, RET 등의 명령어를 사용하면 순차적인 실행 흐름이 끊기고, 특정 메모리 주소가 프로그램 카운터에 저장된다.

#### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식.

> ##### 스택 영역
>
> 메모리 안에 스택처럼 사용하기로 정해져 있는 영역.\
> 일반 스택 자료구조와는 달리 아래에서부터 값이 채워지고, 포인터 값은 감소한다.
>
> <img width="300" alt="운영체제 스택" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/81620001/6af0d388-dbf3-43c4-a8a8-d682cdc78143">\
> _사진 출처: 서강대학교 운영체제 강의자료, 김영재 교수님_

#### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식(displacement addressing mode)

명령어는 다음 형식을 지닌다.

|연산 코드|레지스터|오퍼랜드|
|---|---|---|

- **상대 주소 지정 방식**
  - 유효 주소: 오퍼랜드와 프로그램 카운터의 값을 더한 값
  - if문 처럼 분기되는 특정 주소의 코드를 실행할 때 사용
- **베이스 레지스터 주소 지정 방식**
  - 유효 주소: 오퍼랜드와 베이스 레지스터의 값을 더한 값.

---

## 04-3 명령어 사이클과 인터럽트

### 명령어 사이클(Instruction cycle)

1. 인출 사이클(Fetch cycle)
   - 메모리에 있는 명령어를 CPU로 가져오는 단계
2. 실행 사이클(Execution cycle)
   - CPU로 가져온 명령어를 실행하는 단계
3. 간접 사이클
   - 메모리 접근이 더 필요한 경우
   - 예시) 간접 주소 지정 방식

### 인터럽트(Interrupt)

인터럽트는 CPU가 수행 중인 작업을 방해하는 신호이다. 다음 종류가 있다.

- 동기 인터럽트(synchronous interrupt) - 예외(exception)
  - 폴트(fault)
  - 트랩(trap)
  - 중단(abort)
  - 소프트웨어 인터럽트
- 비동기 인터럽트(asyncrhonous interrupt) - 하드웨어 인터럽트
  - 막을 수 있는 인터럽트(maskable interrupt)
  - 막을 수 없는 인터럽트(non maskable interrupt)

#### 동기 인터럽트 - 예외

CPU가 명령어를 수행하다가 오류와 같은 예상치 못한 상황에 마주쳤을 때 발생하는 인터럽트.

- fault: 예외를 처리한 직후 예외가 발생한 명령어부터 실행 재개
- trap: 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행 재개
- abort: 실행 중인 프로그램을 강제로 중단
- 소프트웨어 인터럽트: 시스템 호출[^3]이 발생했을 때.

[^3]: 시스템 호출은 9장에서 설명

#### 비동기 인터럽트 - 하드웨어 인터럽트

주로 입출력장치에 의해 발생하는 인터럽트이다. 다음 예시가 있다.

- 프린터가 작업을 끝냈다고 *완료 알림*을 보낼 때
- 키보드가 어떤 입력을 받아들였을 때 이를 처리하기 위해 CPU에게 *입력 알림*을 보낼 때

> **CPU가 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.**
>
>예시) 프린터를 사용할 때\
>인터럽트 사용 안 할 때: 프린터의 작업이 완료할 때까지 CPU가 주기적으로 확인한다.\
>인터럽트 사용 할 때: CPU는 자기 할 일을 하다가 프린터의 완료 알림을 받는다

##### 하드웨어 인터럽트 처리 순서

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다
   - 인터럽트 요청 신호: 인터럽트로 실행 흐름을 끊어도 되는지 확인하기 위한 요청
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 확인
   - 인터럽트 플래그가 '불가능'으로 설정되어 있어도 우선순위가 높은 정전이나 하드웨어 고장으로 인한 인터럽트는 실행
4. 인터럽트를 받아들일 수 있다면 현재 작업을 *스택에 백업*
5. **인터럽트 벡터**를 참조해서 **인터럽트 서비스 루틴**을 실행
   - 인터럽트 벡터: 다양한 인터럽트 서비스 루틴을 식별하기 위한 정보. 인터럽트 서비스 루틴 시작 주소 포함
   - 인터럽트 서비스 루틴(ISR) = 인터럽트 핸들러: 인터럽트를 처리하기 위한 프로그램. 입출력장치마다 다름.
6. 인터럽트 서비스 루틴 실행이 끝나면 백업한 작업을 복구해서 실행 재개
