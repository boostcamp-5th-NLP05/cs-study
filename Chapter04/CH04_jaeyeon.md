# Chapter 04: CPU의 작동 원리

CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치이다.

이러한 CPU를 구성하는 ALU와 제어장치가 무엇인지 알아보자.

## ALU

<img width="584" alt="cpu-alu" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/25fa5741-8e22-4e8b-909c-052ea2eb6689">


여기서 중요한 점은 ALU는 레지스터에 있는 값들을 다룬다는 점이다.

메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리기 때문에 매번 연산마다 메모리에 접근하면 연산 시간이 매우 오래 걸릴 것이다.

그렇기 때문에 레지스터에 있는 값들로 연산을 진행한 후 일단 레지스터에 그 값을 저장한다.

연산을 진행한 후에 플래그 레지스터에 플래그를 쓰는데, 플래그의 예시는 아래와 같다.

| 부호 플래그 | 연산한 결과의 부호를 나타낸다 |
| --- | --- |
| 제로 플래그 | 연산 결과가 0인지 여부를 나타낸다 |
| 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 나타낸다 |
| 오버플로우 플래그 | 오버플로우가 발생했는지를 나타낸다 |
| 인터럽트 플래그 | 인터럽트가 가능한지 나타낸다. |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다. |

## 제어장치

제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다. 또한 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

제어정치가 무엇을 받아들이고 무엇을 내보내는지 알아보자.

1. 제어장치는 클럭 신호를 받아들인다
    
    여기서 클럭이란 컴퓨터의 시간 단위라고 볼 수 있다. 컴퓨터 부품들의 작동은 클럭 단위에 맞춰서 실행되며 명령어는 1클럭, 4클럭, 10클럭과 같이 클럭 단위에 걸쳐 실행된다. 또한 CPU의 성능을 나타내는 지표 중 GHz 단위로 쓰는 것이 클럭 스피드이며 초당 몇 개의 클럭을 처리하는지 나타내는 지표이다.
    
2. 제어장치는 ‘해석해야 할 명령어’를 받아들인다.
    
    CPU가 해석해야 될 명령어는 명령어 레지스터에 저장되는데, 제어장치는 이 명령어 레지스터로 부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생 시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.
    
3. 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.
    
    이전 연산에서 진행하고 남은 플래그 레지스터 값을 참고해야 현태 상태 정보를 알고 올바른 제어신호를 보낼 수 있다.
    
4. 제어장치는 시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호를 받아들인다.
    
    

## 레지스터

앞서 CPU의 구성 요소 중 레지스터를 많이 보았다. 과연 레지스터는 어떤 종류가 있으며 어떤 역할을 하는지 알아보자.

| 프로그램 카운터 | 메모리에서 읽어들일 명령어의 주소를 저장 |
| --- | --- |
| 명령어 레지스터 | 메모리에서 읽어 들인 명령어를 저장, 이를 해석 후 제어 신호 내보냄 |
| 메모리 주소 레지스터 | 메모리의 주소를 저장 |
| 메모리 버퍼 레지스터 | 메모리와 주고 받을 값을 저장 |
| 플래그 레지스터 | 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장 |
| 범용 레지스터 | 일반적인 상황에서 사용, 데이터와 주소 모두 저장 가능 |
| 스택 포인터 | 현재 스택의 top이 어디에 위치해있는지 알려주는 역할 |
| 베이스 레지스터 | 주소값들의 기준 주소 역할 |

### 스택 주소 지정 방식

스택과 포인터를 이용한 주소 지정 방식이다. 스택은 메모리 안에 존재하며 데이터를 스택 자료구조처럼 차곡차곡 쌓는다. 스택 포인터는 현재 top의 위치가 어딘지 알려주는 역할을 한다. 하지만 기억해야할 것은, 보통 스택은 데이터를 쌓아올리고 스택 포인터를 증가시키지만, 운영체제에서의 스택은 메모리 주소가 높은 곳에서부터 낮은 곳으로 할당하기 때문에 스택 포인터가 감소한다는 것이다. 

### 변위 주소 지정 방식

오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다. 

- 상대 주소 지정 방식
    
    오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다. 현재 프로그램 카운터에 저장된 메모리 주소에서 특정 값만큼 떨어진 주소에 저장된 명령어를 실행한다. 
    
- 베이스 레지스터 주소 지정 방식
    
    오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다. 현재 기준 주소(베이스 레지스터의 값)로부터 특정 값(오퍼랜드의 값)만큼 떨어진 곳에 있는 메모리에 접근한다. 
    

## 명령어 사이클

CPU가 명령어를 처리할 때, 처리 과정에는 어떤 정해진 흐름이 있고 CPU는 이를 반복하는데 이러한 흐름을 명령어 사이클이라고 한다.

사이클은 크게 아래와 같이 구성된다.

- 인출 사이클 : 메모리에 있는 명령어를 CPU로 가지고 오는 단계이다.
- 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계이다.
- 간접 사이클 : 명령어 실행을 위해 메모리에 추가적으로 접근하는 단계이다.

<img width="288" alt="cycle" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/776aabc4-c917-4e68-a330-55d9bc9c2fba">


## 인터럽트

CPU의 작업을 방해하는 신호를 인터럽트라고 한다. 

CPU가 원래 하던 일을 멈추고 다른 일을 해야하는 상황이 올 때를 인터럽트라고 생각하면 편하다.

인터럽트에는 크게 두 가지 종류가 있다.

- 동기 인터럽트
    
    CPU에 의해 발생하는 인터럽트이다. 프로그램에 오류가 생기는 등의 문제가 생겼을 때 인터럽트를 일으키는데, 이런 점에서 동기 인터럽트는 예외라고 한다. 코딩하다보면 RaiseException과 같은 에러를 많이 봤을 텐데, 이 같은 경우가 동기 인터럽트이다. 
    
- 비동기 인터럽트
    
    주로 입출력장치에 의해 발생하는 인터럽트이다. CPU가 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)를 보낸다. 하드웨어 인터럽트라고 부르기도 한다.
    

### 하드웨어 인터럽트

하드웨어 인터럽트는 알림과도 같은 인터럽트이다. 명령어를 효율적으로 처리하기 위해 사용하기도 한다.

예를 들어 특정 입출력 작업이 오래 걸린다면 입출력 작업을 계속 기다리는 것보다는 다른 작업을 처리하다가 입출력 작업이 끝났을 때 다시 입출력 작업을 다루는 것이 효율적일 것이다. 이럴 때 입출력 작업이 끝났다고 신호를 보낼 때 인터럽트를 사용한다. 

### 하드웨어 인터럽트 처리 순서

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
6. 인터럽트 서비스 루틴이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.

- 인터럽트 요청 신호 : 인터럽트를 해도 되는지 묻는 신호
- 인터럽트 플래그 : 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그
    
    하지만 무시할 수 없는 인터럽트가 있다는 것도 염두에 둬야한다.
    
- 인터럽트 서비스 루틴(인터럽트 핸들러) : 인터럽트를 처리하기 위한 프로그램
- 인터럽트 벡터 : 인터럽트 서비스 정보를 식별하기 위한 정보

‘CPU가 인터럽트를 처리한다’라는 말은 ‘인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 다시 되돌아온다’는 말과 같다. 인터럽트 서비스 루틴을 실행하는 동안 원래 레지스터에 있던 값들과 작업 내역은 스택으로 잠시 옮겨진다. 

![cycle2](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/ceea50d2-3930-4041-8757-d8176c8d0b46)

