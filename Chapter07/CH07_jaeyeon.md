# Chapter 07. 보조기억장치

## 07-1. 다양한 보조기억장치

### 하드 디스크

하드 디스크는 자기적인 방식으로 데이터를 저장하는 보조기억장치이다.

큰 개념으로 봤을 때, 하드 디스크는 동그란 원판에 데이터를 저장하고 이 원판을 회전 시켜 뾰족한 리더기로 데이터를 읽는다.

구성 요소는 아래와 같다.

- 플래터 : N극과 S극을 저장하는 실질적으로 데이터가 저장되는 곳
- 스핀들 : 플래터를 회전 시키는 구성 요소
- 헤드 : 플래터를 대상으로 데이터를 읽고 쓰는 구성 요소
- 디스크 암 : 헤드를 원하는 위치로 이동시키는 구성 요소

플래터는 트랙과 섹터라는 단위로 데이터를 저장한다. 

<img width="621" alt="하드디스크" src="https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/4b011660-1f6e-48bf-8bdc-0a2eac125280">

섹터는 일반적으로 512바이트의 크기를 가지고 있으며 하드 디스크에 따라 차이가 있다.

여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위를 실린더라고 한다.

연속된 정보는 보통 한 실린더에 기록되며 4개의 섹터에 걸쳐 정보를 저장할 땐 첫 번째 플래터의 윗면과 뒷면, 두 번째 플래터의 윗면과 뒷면에 데이터를 저장한다. 디스크 암을 움직이지 않고도 한 번에 데이터에 접근할 수 있기 때문이다.

저장된 데이터에 접근하는 시간은 크게 아래와 같다.

- 탐색 시간 : 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
- 회전 지연 : 헤드가 있는 곳으로 플래터를 회전시키는 시간
- 전송 시간 : 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간

보통 데이터에 접근하는 시간을 줄이기 위해서 플래터를 회전시키는 동안 헤드를 동시에 움직여서 같은 시간에 헤드가 데이터 위에 위치하게끔 한다.

### 플래시 메모리

플래시 메모리는 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치이며, USB, SD 카드 SDD 등에 쓰인다.

플래시 메모리에서 데이터를 저장하는 가장 작은 단위는 셀이다. 이러한 셀들이 모여 MB, GB, TB를 이룬다. 

하나의 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 달라진다., 1비트만 저장할 수 있으면 SLC, 2비트를 저장할 수 있으면 MLC, 3비트를 저장할 수 있으면 TLC이다.

- SLC : 하나의 셀에 1비트만 저장할 수 있으며 수명이 길고 비트의 빠른 입출력이 가능하다.
- MLC : 하나의 셀에 2비트를 저장할 수 있으며 SLC보다 속도와 수명은 떨어지지만 대용화하기 유리하다.
- TLC : 하나의 셀에 3비트를 저장할 수 있으며 수명과 속도가 떨어지지만 용량 대비 가격이 저렴하다.

플래시 메모리의 단위들은 아래와 같다.

셀 → 페이지 → 블록 → 플레인 → 다이

플래시 메모리에서 읽기와 쓰기는 페이지 단위로, 삭제는 블록 단위로 이루어진다.

페이지는 Free, Valid, Invalid 상태 중 하나를 가질 수 있는데, Free는 새로운 데이터를 저장할 수 있는 상태, Valid는 유효한 데이터를 가지고 있는 상태, Invalid 상태는 쓰레기값을 저장하고 있는 상태이다.

플래시 메모리는 덮어쓰기가 불가능하기 때문에 Valid 상태의 페이지에는 새 데이터를 저장할 수 없다.

만약 수정을 하고 싶다면 수정 후 다른 페이지에 데이터를 저장해야 한다.

그 후 가비지 컬렉션을 통해 쓰레기값들을 비운다.

## RAID의 정의와 종류

### RAID의 정의

보조기억장치는 수명이 있기 때문에 데이터를 안전하게 관리할 방법이 필요하다.

이러한 방법 중 하나가 RAID(Redundant Array of Independent Disks)인데,

데이터의 안정성 혹은 높은 성능을 위해 여러 개의 물리적 보조기억장치를 하나의 논리적 보조기억장치처럼 사용하는 기술이다.

### RAID의 종류

RAID를 평가할 수 있는 기준은 용량, 의존성, 성능이 있다. 이를 기준으로 평가해보자.

- RAID 0(Striping)
    
    여러 개의 보조기억장치에 데이터를 단순히 나누어 저장하는 구성 방식이다.
    
    ![RAID 0](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/17fa894a-e3cc-48a2-9cbd-227f4e2eaafb)

    
    - 용량 :  감소하지 않기 때문에 좋은 편이다.
    - 의존성 : 디스크 중 하나만 손상돼도 나머지 데이터를 읽을 수 없기 때문에 의존성은 떨어진다.
    - 성능 : 이론상 4배 가량 빠르다.

- RAID 1(Mirroring)
    
    복사본을 만드는 방식이다.
    
    ![RAID 1](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/d1cfb5cf-a300-4379-93a9-f856cc3abc14)

    
    - 용량 : 반으로 줄어든다.
    - 의존성 : RAID 0보다 좋다.
    - 성능 : 읽기 속도는 RAID 0과 같지만 쓰기 속도가 반으로 줄어들었다.

- RAID 4(Saving Space with Parity)
    
    복사본을 두는 대신 오류 검출 및 복구 정보를 담은 패리티 비트를 사용한다.
    
    ![RAID 4](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/8de18d0d-ce72-4d29-ae72-b8b827787337)

    
    - 용량 : 전체 N개의 하드 디스크 중 하나만 제외하고 사용할 수 있어 나쁘지 않다.
    - 의존성 : 디스크 하나가 망가지면 복구가 가능하지만 두 개가 망가지면 복구가 안 된다.
    - 성능 : 읽기, 쓰기 속도는 비슷하지만 데이터를 쓰면 패리티 비트에도 접근해야된다는 단점이 있고, 패리티를 저장하는 장치에 병목 현상이 발생한다.

- RAID 5(Rotating Parity)
    
    하나의 디스크에 패리티를 몰아넣는게 아닌 분산해서 넣는 방식이다.
    
    ![RAID 5](https://github.com/boostcamp-5th-NLP05/cs-study/assets/86578246/d7171967-d205-46a4-804a-6322223c44b4)

    
    - 용량 : RAID 4와 동일하다.
    - 의존성 : RAID 4와 동일하다.
    - 성능 : 패리티 병목을 해결하였기 때문에 RAID 4보다는 좋다.

- RAID 6
    
    두 개의 패리티를 두는 방식이다.
    
    - 용량 : N-2개의 디스크 만큼만 저장할 수 있다.
    - 의존성 : RAID 4, 5보다 안전하다.
    - 성능 : 데이터를 쓸 때마다 패리티 2개에 접근해야하므로 쓰기 속도가 느려진다.
