# Chapter 14 가상 메모리

## 14-1 연속 메모리 할당

- 연속 메모리 할당 방식: 프로세스에 연속적인 메모리 공간을 할당하는 방식  
- **스와핑**
  - 사용되지 않는 프로세스를 메모리에서 보조기억장치로 쫓아내고(**스왑 아웃**), 
  - 다른 프로세스를 해당 영역에 적재(**스왑 인**)하는 메모리 관리 기법. 
  - 보조기억장치의 **스왑 영역**을 사용.
  - 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스 동시 실행 가능
- 메모리 할당 방식
  - **최초 적합(first fit)**
    - 적재할 수 있는 공간을 발견하면 바로 배치
    - 검색 최소화, 빠른 할당
  - **최적 적합(best fit)**
    - 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 배치
  - **최악 적합(worst fit)**
    - 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 배치
- **외부 단편화(external fragmentation)**
  - 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들에 의해 메모리가 낭비되는 현상
  - eg) 20MB - 프로세스 A - 30MB: 메모리에 남아 있는 빈 공간의 합은 50 MB이지만, 50MB 프로세스를 할당할 수 없다.
  - 해결 방안
    - **압축**: 메모리 내 프로세스를 재배치해서 빈 공간을 한 곳에 모으는 방법
      - 단점: 재배치하는 동안 시스템은 다른 일을 못 하고, 많은 오버헤드 발생
    - 페이징 기법: 다음 절에서 설명

## 14-2 페이징을 통한 가상 메모리 관리

- 연속 메모리 할당 방식 문제 &rarr; *페이징으로 해결*
  - 외부 단편화
  - 물리 메모리보다 큰 프로세스 실행 불가
- **가상 메모리**: 실행하고자 하는 프로그램의 일부만 메모리에 적재해서 실제 물리 크기보다 더 큰 프로세스를 실행 가능하게 하는 기술
  - 페이징, 세그멘테이션(서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할하여 메모리에 할당)
- **페이징(paging)**
  - 프로세스의 논리 주소 공간을 **페이지**로 자르고, 메모리 물리 주소 공간을 **프레임**으로 자른 뒤 서로 할당하는 가상 메모리 관리 기법
  - 페이지와 프레임의 크기는 동일
  - 한 프로세스를 불연속적으로 할당할 수 있어서 외부 단편화 방지
  - 페이지 단위 스와핑: **페이지 인/페이지 아웃**
- **페이지 테이블**
  - 페이지 번호와 프레임 번호를 짝지어 줌
  - CPU가 다음에 실행할 명령어 위치를 찾을 수 있기 위해 논리 주소를 연속적으로 배치하고, 페이지 테이블을 사용
- **페이지 테이블 페이스 레지스터(PTBR)**: 프로세스의 페이지 테이블이 적재된 주소 가리킴
- **TLB(Translation Lookaside Buffer)**
  - 페이지 태이블 캐시
  - 페이지 테이블을 메모리에 두면 메모리 접근 시간이 늘어나는 문제 해결
  - TLB hit, TLB miss
- 페이징 시스템 논리 주소
    |페이지 번호|변위(offset)|
    |---|---|
    |페이지 테이블을 통해 프레임 번호로 변환|접근하려는 주소가 프레임의 시작 번지로부터 얼마나 떨어져 있는지|
- **페이지 테이블 엔트리**: 페이지 번호와 프레임 번호 외 정보
    |정보|설명|
    |---|---|
    |**유효 비트(valid bit)**|1: 페이지가 메모리에 적재되어 있다, 0: 그렇지 않다<br>유효 비트가 0인 페이지에 접근하려 하면 **페이지 폴트** 발생. 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재|
    |**보호 비트(protection bit)**|1: 읽고 쓰기 모두 가능, 0: 읽기만 가능<br>코드 영역 등을 보호<br>rwx 조합 구현 가능|
    |**참조 비트(reference bit)**|1: 적재 이후 CPU가 접근한 적 있음, 0: 없음|
    |**수정 비트(modified bit)/dirty bit**|1: 변경된 적이 있음, 0: 없음<br>페이지를 스왑아웃할 때 변경된 내용을 보조기억장치에 기록해야 함|

> **내부 단편화(internal fragmentation)**
>
> - 모든 프로세스가 페이지 단위에 딱 맞게 잘리지 않아서 마지막 페이지에 공간이 남는 메모리 낭비
> - 페이지 크기가 작으면: 내부 단편화 크기 작아지지만 페이지 테이블이 차지하는 공간 커짐.
>
> **페이징의 이점 - 쓰기 시 복사(copy on write)**
>
> - fork 후 부모 프로세스와 자식 프로세스는 동일한 프레임 공유해서 복사본을 만드는 시간과 메모리 낭비 방지
> - 부모 프로세스나 자식 프로세스에 쓰기 작업을 하면 해당 페이지는 별도의 프레임으로 복제
>
> **계층적 페이징/다단계 페이지 테이블**
>
> - 모든 프로세스 테이블 엔트리를 메모리에 두는 것은 낭비
> - 페이지 테이블을 여러 개의 페이지로 자르고, 해당 페이지를 가리키는 페이지 테이블을 두는 방식
>   |바깥 페이지 번호|안쪽 페이지 번호|변위|
>   |---|---|---|
> - 계층이 늘어날수록 페이지 폴트 시 메모리 참조 횟수 많아짐

## 14-3 페이지 교체와 프레임 할당

- **요구 페이징(demand paging)**
  - 필요한 페이지만을 메모리에 적재하는 기법
  - 접근하려는 페이지의 유효 비트가 0일 경우, 페이지 폴트 처리 루틴을 통해 해당 페이지를 메모리로 적재
  - 순수 요구 페이징: 아무런 페이지도 메모리에 적재하지 않은 채 실행
- **페이지 교체 알고리즘**
  - 메모리가 가득 찬 경우 어느 페이지를 쫓아낼 지 결정
  - 페이지 폴트가 적게 나는 알고리즘이 좋음
    |페이지 교체 알고리즘|설명|
    |---|---|
    |**FIFO(First In First Out)**|메모리에 가장 먼저 올라온 페이지부터 교체|
    |**2차 기회(second chance)**|FIFO와 동일하되 참조 비트가 1일 경우, 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간을 설정|
    |**최적(optimal)**|앞으로의 사용 빈도가 가장 낮은 페이지 교체<br>앞으로 오랫동안 사용되지 않을 페이지 예측 어려움. 다른 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용.|
    |**LRU(Least Recently Used)**|가장 오랫동안 사용되지 않은 페이지 교체.<br>최적 페이지 교체 알고리즘과 비슷한 아이디어<br>*최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것*|
- **스래싱(thrashing)**
  - *지나치게 빈번한 페이지 교체에 의해 CPU 이용률이 떨어지는 문제*
  - 프로세스가 사용할 수 있는 프레임 수가 적으면 페이지 폴트 자주 발생
  - 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
  - *멀티프로그래밍의 정도(degree of multiprogramming)(메모리에서 동시 실행되는 프로세스의 수)* 를 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어져서 CPU 이용률 떨어짐
- 프레임 할당 방식
  - 프로세스 크기만 고려하는 **정적 할당 방식**, 실행 과정도 고려하는 **동적 할당 방식**
  - **균등 할당**:모든 프로세스에 균등하게 프레임 제공
  - **비례 할당**: 프로세스 크기에 비례해서 프레임 제공
  - **작업 집합 모델**
    - **작업 집합(working set)**: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합
    - 작업 집합의 크기만큼 프레임 할당해서 빈번한 페이지 교체 방지
  - **페이지 폴트 빈도 기반**: 페이지 폴트율이 상한선보다 높아지면 프레임 추가 할당, 하한선보다 낮아지면 프레임 회수
